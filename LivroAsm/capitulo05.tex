%------------------------------------------------------------------------------------
%	CHAPTER 4
%------------------------------------------------------------------------------------
\chapterimage{headerCap.jpeg}
\chapter{Registradores de 64 Bits}

\begin{remark}
	Dê o poder ao homem, e descobrirá quem realmente ele é. (Maquiavel - Diplomata, Autor e Historiador Italiano) 
\end{remark}

\section{Retornamos ao Hello World}\index{Registradores de 64 Bits}
Podemos pensar o seguinte, até o momento para compilar nossos programas usamos 64 Bits, na instrução "nasm -f elf64", e isso é uma grande verdade, porém nossos registradores são todos de 32 bits, e isso causa um problema, pois não vimos nada de, por exemplo PILHAS, pois só funcionam em registradores de 64 bits. Assim devemos aprender a usá-los e a usufruir de seus benefícios.

Vamos lembrar da nossa tabela exposta no primeiro capítulo desse livro:
\begin{table}[H]
	\centering 
	\begin{tabular}{c | c | l }
		\textbf{64 bits} & \textbf{32 bits} & \textbf{Utilização} \\ \hline
		rax & eax & Valores que são retornados dos comandos em um registrador \\
		rbx & ebx & Registrador preservado. Cuidado ao utilizá-lo \\
		rcx & ecx & Uso livre como por exemplo contador \\
		rdx & edx & Uso livre em alguns comandos \\
		rsp & esp & Ponteiro de uma pilha \\
		rbp & ebp & Registrador preservado. Algumas vezes armazena ponteiros de pilhas \\
		rdi & edi & Na passagem de argumentos, contém a quantidade desses \\
		rsi & esi & Na passagem de argumentos, contém os argumentos em si \\
	\end{tabular}
\end{table}

A primeira coluna contém os registradores que veremos neste capítulo, a mudança básica é simples trocamos a letra "E" pela letra "R". No arquivo \textbf{makefile} já visto não precisaremos trocar uma única linha e por enquanto não usaremos nenhuma biblioteca, vamos começar limpos e entender quais são as mudanças necessárias. Começamos por criar um arquivo chamado \textbf{lerarquivo.asm} com a seguinte codificação:
\begin{lstlisting}[]
section .data
  mensagem: db "Hello World 64 bits!!!", 0xA
  tam: equ $- mensagem

section .text

global _start:

_start:
\end{lstlisting}	

Até o presente momento nenhuma mudança no nosso código (os dois pontos é um mero preciosismo da minha parte), porém:
\begin{lstlisting}[]
  mov rax, 0x1
  mov rdi, 0x1
  mov rsi, mensagem
  mov rdx, 0x17
  syscall
\end{lstlisting}

Agora começamos a verdadeira mudança, se bem lembramos a sequencia seria EAX, EBX, ECX e EDX, porém dois registradores são trocados, EAX muda realmente para RAX mas se reparou bem seu valor agora não é "0x4" como era, EBX agora vai mudar para RDI (e não RBX) e ECX para RSI (e não RCX como seria de se esperar) e finalmente RDX para RDX (como seria de se esperar). Além disso tudo, aparece a instrução "syscall" que procede a chamada do antigo "int 0x80".

Agora vamos as diferenças para encerrar o programa:
\begin{lstlisting}[]
  mov rax, 0x3C
  xor rdi, rdi
  syscall
\end{lstlisting}	

A primeira instrução uma simples mudança no endereçamento no qual ao invés de "0x1" agora usamos o "0x3C", zeramos o segundo registrador mas dessa vez utilizamos o comando XOR e finalmente uma chamada a "syscall" que fará o serviço de entregar o bloco de instruções ao computador.

E ao compilar e executar teremos corretamente a mensagem aparecendo no terminal: \\
{\ttfamily Hello World 64 bits!!!}

Nosso makefile agora terá a seguinte codificação:
\begin{lstlisting}[]
NOME = mostrar

all: $(NOME).o
	ld -s -o $(NOME) $(NOME).o
	rm -rf *.o

%.o: %.asm
	nasm -f elf64 $<
\end{lstlisting}	

Esse exemplo conhecemos que não se trata então de uma simples mudança de registradores mas quase reaprender novamente os comandos, mas não se preocupe apenas mantenha a mente afiada que veremos muito mais nesse capítulo.

\section{Pilhas}\index{Registradores de 64 Bits}
Se o capítulo passado trouxe a sensação que agora vamos repetir todos os programas já vistos anteriormente, sinto em lhe dizer que está é totalmente errônea, porém sinta-se a vontade para refazê-los em 64 bits para treinar os novos registradores. Neste capítulo veremos do que são capazes, uma dessas mudanças é o conceito de \textbf{Pilhas}.

Não consigo compreender a confusão que faz com o iniciante a respeito desse assunto. Imaginemos uma pilha de caixas (uma sobre a outra), pensemos em umas 10, agora precisamos de uma para colocar algumas coisas, é óbvio que vamos pegar a última que colocamos (ou seja a que está em cima da pilha e não a primeira lá embaixo ou qualquer uma do meio nos arriscando a derrubar toda pilha), por isso mesmo \textbf{Pilhas} são conhecidas como LIFO (\textit{Last in First Out}), ou seja, a última que entrou na pilha será primeira a ser retirada.

Vamos começar nosso programa com a definição dos registradores:
\begin{lstlisting}[]
section .data
  LF            equ 10  ; Line Feed
  NULL          equ 0   ; Final da String
  EXIT_SUCESS   equ 0   ; Operação com Sucesso
  SYS_EXIT      equ 60  ; Codigo de chamada para finalizar

  STDIN         equ 0   ; System.in
  STDOUT        equ 1   ; System.out
  STDERR        equ 2   ; System.err

  SYS_READ      equ 0   ; read
  SYS_WRITE     equ 1   ; print

  liv1          db '1. Moby Dick', LF, NULL
  liv2          db '2. Tom Swayer', LF, NULL  
  liv3          db '3. Duna', LF, NULL
\end{lstlisting}

Apenas definimos os valores para nossos registradores e devemos observar os marcadores: liv1, liv2 e liv3 são eles que colocaremos na nossa pilha. O escopo principal do nosso programa:
\begin{lstlisting}[]
section .text

global _start

_start:
  ; Colocar os livros na pilha
  push      liv1
  push      liv2
  push      liv3
  ; Pegar um livro da pilha
  pop       rdi
  call      _imprimir
  pop       rdi
  call      _imprimir
  pop       rdi
  call      _imprimir
  ; Finalizar
  mov       rax, SYS_EXIT
  mov       rbx, EXIT_SUCESS
  syscall
\end{lstlisting}

Temos dois comandos novos: \textbf{PUSH} e \textbf{POP}, o primeiro deles insere um dado na pilha enquanto que o segundo obtém esse dado, sempre através do registrador \textbf{RDI}, ou seja o dado entra na pilha e saí pelo registrador \textbf{RDI}. Vamos para a função de impressão do dado:
\begin{lstlisting}[]
_imprimir:
  call  _ctCaracteres
  mov   rax, SYS_WRITE
  mov   rsi, rdi
  mov   rdi, STDOUT
  syscall
  ret
\end{lstlisting}

Devemos lembrar que para mostrar algo na saída precisamos ter conhecimento de seu tamanho, isso será realizado pela próxima função, aqui apenas fazemos o mesmo do programa anterior, movendo os registradores RAX (0x1), RSI (primeiro pois RDI contém o elemento da pilha) e RDI com seu valor de saída (0x1). E verificamos quantos caracteres temos no elemento de saída:
\begin{lstlisting}[]
_ctCaracteres:
  mov   rbx, rdi
  mov   rdx, 0
fazLoop:
  cmp   byte[rbx], NULL
  je    termina
  inc   rdx
  inc   rbx
  jmp   fazLoop
termina:
  ret 
\end{lstlisting}

Já vimos isso no passado, para contarmos os caracteres simplesmente a cada carácter não nulo incrementamos o valor de um registrador (neste caso RDX). E está tudo pronto e teremos como resposta ao executar este programa os livros colocados na pilha porém em ordem inversa: \\
{\ttfamily 3. Duna} \\
{\ttfamily 2. Tom Swayer} \\
{\ttfamily 1. Moby Dick}

Este é um conceito extremamente importante na programação, pois podemos organizar melhor a nossa informação.
